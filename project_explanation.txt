MINDVAULT: DEEP DIVE TECHNICAL DOCUMENTATION

1. PROJECT OVERVIEW
MindVault is a full-stack MERN application (MongoDB, Express, React, Node) that serves as a "Second Brain" for saving links. This document details exactly how the code works, step-by-step.

--------------------------------------------------------------------------------

2. DEEP DIVE: AUTHENTICATION & JWT (HOW IT WORKS)

The security of this app relies on JSON Web Tokens (JWT). Here is the exact technical flow:

PHASE 1: SIGNING UP (Creation)
1. User enters username/password on the Frontend specific page.
2. Frontend sends POST request to `http://localhost:3000/api/v1/signup`.
3. Backend (`index.ts`) receives the request.
4. Backend uses `UserModel.create()` to save the raw strings into the MongoDB `users` collection.
   * IMPROVEMENT NOTE: This is where `bcrypt.hash` should happen, but currently it saves plain text.

PHASE 2: SIGNING IN (Token Generation)
1. User enters credentials.
2. Frontend sends POST request to `http://localhost:3000/api/v1/signin`.
3. Backend checks the DB. If a user is found:
   * It calls `jwt.sign({ id: currentuser._id }, jwt_key)`.
   * This creates a cryptic string (the Token) that encodes the User's unique MongoDB ID (`_id`) inside it.
4. Backend sends this Token back to the Frontend: `{ token: "ey..." }`.
5. Frontend (`SignIn.tsx`) receives the token and immediately saves it to the browser's LocalStorage: `localStorage.setItem("token", response.data.token)`.

PHASE 3: PROTECTED REQUESTS (The Middleware)
Every time the user tries to Add Content or Share Brain, the Frontend attaches this token to the request.
1. Frontend Code: `headers: { Authorization: localStorage.getItem("token") }`.
2. Backend Middleware (`userMiddleware` in `middleware.ts`):
   * Intercepts the request before it hits the main route.
   * Reads `req.headers["authorization"]`.
   * Calls `jwt.verify(header, jwt_key)` to decode the token.
   * Extracts the hidden `req.userId` from the token.
   * Validates that this user creates the request.
   * Executes `next()`, allowing the request to proceed to the actual function (e.g., adding content).

--------------------------------------------------------------------------------

3. DEEP DIVE: "ADD CONTENT" FLOW
(From Click to Database)

Scenario: User is on the Dashboard and wants to add a YouTube link.

STEP 1: USER INTERACTION (Frontend)
- File: `DashBoard.tsx`
- Action: User clicks the "Add content" button.
- Logic: `setModelOpen(true)` runs, causing React to render the `CreateContentModel` component (a popup form).

STEP 2: FORM SUBMISSION (Frontend Logic)
- File: `CreateContentModel.tsx`
- Action: User types "My Video" and "https://youtube.com/..." and clicks "Submit".
- Function: `addcontent()` is called.
- Code Execution:
  1. It grabs values from the input references (`titleref.current.value`, `linkref.current.value`).
  2. It executes `axios.post(`${BACKEND_URL}/api/v1/content`, ...)`
  3. CRITICAL: It looks into LocalStorage, grabs the JWT token, and attaches it to the request headers under "Authorization". This proves "I am User X".

STEP 3: NETWORK REQUEST
- Method: POST
- URL: `/api/v1/content`
- Body: `{ title: "My Video", link: "...", type: "youtube" }`
- Header: `Authorization: eyJhbGci...`

STEP 4: BACKEND PROCESSING (Server)
- File: `middleware.ts` -> `index.ts`
1. The `userMiddleware` runs first. It decodes the token and sets `req.userId` to the user's Mongo ID.
2. The code enters `app.post("/api/v1/content", ...)` handler.
3. It extracts `title`, `link`, `type` from `req.body`.
4. It calls Mongoose:
   `await ContentModel.create({ title, link, type, userId: req.userId, tags: [] })`
   * Note how `userId` comes from the middleware (the token), NOT the user's input. This prevents hacking/spoofing other users.

STEP 5: DATABASE & RESPONSE
- MongoDB creates a new document in the `contents` collection.
- Backend sends HTTP 200 JSON: `{ message: "sucessfully content addeed" }`.
- Frontend receives this, waits for the promise to resolve, and then closes the modal (`onClose()`).

--------------------------------------------------------------------------------

4. DEEP DIVE: "SHARE BRAIN" FLOW
(Making a private dashboard public)

Scenario: User wants to share their list with a friend.

STEP 1: CLICK (Frontend)
- File: `DashBoard.tsx`
- Action: User clicks "Share brain" button.
- Logic: An async arrow function is triggered immediately.

STEP 2: API CALL
- Code: `axios.post(..., { share: true }, headers...)`
- Frontend sends a request telling the server: "I want to enable sharing for my account."

STEP 3: BACKEND LOGIC (The Decision)
- File: `index.ts` route `/api/v1/brain/share`
1. Middleware verifies user identity (`req.userId`).
2. Code checks `if (share)` is true.
3. Database Query: `await Linkmodel.findOne({ userId })`.
   * IT CHECKS: Does a share link already exist for this user?
   * CASE A (Exists): It immediately returns the existing `hash` (e.g., "abc12345").
   * CASE B (New): It generates a random string `hash = random(10)`. Then it runs `Linkmodel.create({ userId, hash })` to save this permanent mapping in the DB.
4. Returns JSON: `{ message: "abc12345" }` (The hash).

STEP 4: FINAL DISPLAY
- Frontend receives "abc12345".
- Code: `const shareurl = "http://localhost:5173/share/abc12345"`
- It triggers a browser `alert(shareurl)` to show the User the link.

--------------------------------------------------------------------------------

5. DEEP DIVE: ACCESSING A SHARED BRAIN
(Reading Public Data)

Scenario: A stranger clicks `http://localhost:5173/share/abc12345`.

STEP 1: ROUTING (Frontend)
- React Router detects the pattern `/share/:shareLink`.
- It mounts the `SharedBrain.tsx` page (assumed filename based on logic).
- It extracts "abc12345" from the URL parameters.

STEP 2: FETCHING DATA (No Auth Required)
- Frontend calls `axios.get("/api/v1/brain/abc12345")`.
- NOTE: This request does NOT need a token. It is public.

STEP 3: BACKEND LOOKUP CHAIN
- File: `index.ts` route `/api/v1/brain/:shareLink`
1. Lookup 1: `Linkmodel.findOne({ hash: "abc12345" })`.
   * Result: Finds the Link document which contains the `userId` of the owner.
2. Lookup 2: `ContentModel.find({ userId: link.userId })`.
   * Result: Finds ALL content belonging to that owner.
3. Lookup 3: `UserModel.findOne({ _id: link.userId })`.
   * Result: Gets the username (e.g., "Alice").

STEP 4: RESPONSE
- Server sends:
  `{ username: "Alice", contents: [ { title: "Video A", ... }, { title: "Tweet B", ... } ] }`

STEP 5: RENDER
- Frontend takes this JSON list and maps over the `contents` array.
- For each item, it renders a `<Card />` component, just like the Dashboard, but read-only.

--------------------------------------------------------------------------------

This document covers the exact "Click-to-Database" lifecycle of every major feature you requested.
